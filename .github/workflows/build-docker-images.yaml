name: Build and push Docker images

on:
  # Build images daily
  schedule:
    - cron: 0 0 * * *
  push:
    branches:
      - master
    paths:
      - docker/**
  pull_request:
    branches:
      - master
    paths:
      - docker/**
  workflow_dispatch:
    inputs:
      force-rebuild:
        type: boolean
        description: Force rebuild (even if images for the latest commit already exist)
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_SERVER: ${{ github.repository_owner }}/vmangos-server
  IMAGE_NAME_DATABASE: ${{ github.repository_owner }}/vmangos-database
  PATCHES_REPOSITORY_URL: https://github.com/mserajnik/vmangos-deploy-patches.git
  OCI_ANNOTATION_AUTHORS: ${{ vars.OCI_ANNOTATION_AUTHORS || github.repository_owner }}
  OCI_ANNOTATION_URL: https://github.com/${{ github.repository }}
  OCI_ANNOTATION_DOCUMENTATION: https://github.com/${{ github.repository }}/blob/master/README.md
  OCI_ANNOTATION_SOURCE: https://github.com/${{ github.repository }}
  OCI_ANNOTATION_VENDOR: ${{ vars.OCI_ANNOTATION_VENDOR || github.repository_owner }}
  OCI_ANNOTATION_LICENSES: GPL-2.0
  OCI_ANNOTATION_SERVER_TITLE: vmangos-deploy - VMaNGOS server image
  OCI_ANNOTATION_SERVER_DESCRIPTION: VMaNGOS is a server emulator supporting versions 1.6.1 to 1.12.1.
  OCI_ANNOTATION_SERVER_BASE_NAME: ubuntu:24.04
  OCI_ANNOTATION_DATABASE_TITLE: vmangos-deploy - VMaNGOS database image
  OCI_ANNOTATION_DATABASE_DESCRIPTION: Database for the VMaNGOS server emulator.
  OCI_ANNOTATION_DATABASE_BASE_NAME: mariadb:11.8

jobs:
  setup:
    name: Setup
    runs-on: ubuntu-24.04
    outputs:
      commit-hash: ${{ steps.latest-commit-hash.outputs.result }}
      images-already-exist: ${{ steps.images-already-exist.outputs.result }}

    steps:
      - name: Get latest commit hash
        uses: actions/github-script@v8
        id: latest-commit-hash
        with:
          result-encoding: string
          retries: 3
          script: |
            const ref = await github.rest.git.getRef({
              owner: 'vmangos',
              repo: 'core',
              ref: 'heads/development',
            })

            return ref.data.object.sha

      # We check if the workflow was triggered by a schedule and if today is
      # Monday, in which case we want to trigger a (re)build in any case (to
      # keep the Docker images up-to-date).
      #
      # We also check if the "force rebuild" input is checked when the workflow
      # is triggered manually; if yes, we also want to (re)build.
      - name: Determine if images for commit already exist
        id: images-already-exist
        run: |
          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            if [[ "$(date +%u)" -eq 1 ]]; then
              echo "result=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          if [[ "${{ inputs.force-rebuild }}" == "true" ]]; then
            echo "result=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          ghcr_token=$(echo ${{ secrets.GITHUB_TOKEN }} | base64)
          tags=$(skopeo list-tags --registry-token ${ghcr_token} docker://${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DATABASE }} | jq '.Tags[]')

          if grep -q "${{ steps.latest-commit-hash.outputs.result }}" <<< "${tags}"; then
            echo "result=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "result=false" >> $GITHUB_OUTPUT

      # If the original MariaDB entrypoint script changes, we can't guarantee
      # that our custom version (which relies on functions defined in the
      # original) will still work, so we fail the workflow run at this point.
      - name: Check if MariaDB entrypoint script has been updated
        id: mariadb-entrypoint-check
        run: |
          known_entrypoint=https://raw.githubusercontent.com/MariaDB/mariadb-docker/a3c37fa8970080971ffc1b6a2aa7d02b97d6b00e/11.8/docker-entrypoint.sh
          latest_entrypoint=https://raw.githubusercontent.com/MariaDB/mariadb-docker/master/11.8/docker-entrypoint.sh
          curl -o known-entrypoint.sh $known_entrypoint
          curl -o latest-entrypoint.sh $latest_entrypoint
          diff known-entrypoint.sh latest-entrypoint.sh

  build-and-push-server-images:
    name: Build and push server images
    needs: setup
    if: ${{ needs.setup.outputs.images-already-exist != 'true' }}
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: true
      matrix:
        client-version: [5875, 5464, 5302, 5086, 4878, 4695, 4544]
        runner: [ubuntu-24.04, ubuntu-24.04-arm]
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine platform
        id: platform
        run: |
          if [ "${{ matrix.runner }}" == "ubuntu-24.04-arm" ]; then
            echo "platform=linux/arm64" >> $GITHUB_OUTPUT
            echo "arch=arm64" >> $GITHUB_OUTPUT
          else
            echo "platform=linux/amd64" >> $GITHUB_OUTPUT
            echo "arch=amd64" >> $GITHUB_OUTPUT
          fi

      - name: Generate timestamp
        id: generate-timestamp
        run: echo "timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      - name: Generate single-arch tag
        id: generate-tag
        run: |
          echo "tag=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_SERVER }}:${{ matrix.client-version }}-${{ needs.setup.outputs.commit-hash }}-${{ steps.platform.outputs.arch }}" >> $GITHUB_OUTPUT

      # See https://github.com/opencontainers/image-spec/blob/main/annotations.md
      - name: Generate OCI annotations
        uses: actions/github-script@v8
        id: generate-annotations
        env:
          COMMIT_HASH: ${{ needs.setup.outputs.commit-hash }}
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_SERVER }}
          CLIENT_VERSION: ${{ matrix.client-version }}
          TIMESTAMP: ${{ steps.generate-timestamp.outputs.timestamp }}
        with:
          result-encoding: string
          script: |
            const annotations = [
              { key: 'created', value: process.env.TIMESTAMP },
              { key: 'authors', envKey: 'OCI_ANNOTATION_AUTHORS' },
              { key: 'url', envKey: 'OCI_ANNOTATION_URL' },
              { key: 'documentation', envKey: 'OCI_ANNOTATION_DOCUMENTATION' },
              { key: 'source', envKey: 'OCI_ANNOTATION_SOURCE' },
              { key: 'version', envKey: 'COMMIT_HASH' },
              { key: 'revision', envKey: 'COMMIT_HASH' },
              { key: 'vendor', envKey: 'OCI_ANNOTATION_VENDOR' },
              { key: 'licenses', envKey: 'OCI_ANNOTATION_LICENSES' },
              { key: 'ref.name', value: `${process.env.IMAGE}:${process.env.CLIENT_VERSION}-${process.env.COMMIT_HASH}` },
              { key: 'title', envKey: 'OCI_ANNOTATION_SERVER_TITLE' },
              { key: 'description', envKey: 'OCI_ANNOTATION_SERVER_DESCRIPTION' },
              { key: 'base.name', envKey: 'OCI_ANNOTATION_SERVER_BASE_NAME' },
            ].map(({ key, value, envKey }) => {
                const resolvedValue = value ?? process.env[envKey] ?? ''
                const escapedValue = resolvedValue.replace(/'/g, "'\\''")
                return `--annotation 'org.opencontainers.image.${key}=${escapedValue}'`
              })
              .join(' ')

            return annotations

      - name: Generate OCI labels
        uses: actions/github-script@v8
        id: generate-labels
        env:
          COMMIT_HASH: ${{ needs.setup.outputs.commit-hash }}
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_SERVER }}
          CLIENT_VERSION: ${{ matrix.client-version }}
          TIMESTAMP: ${{ steps.generate-timestamp.outputs.timestamp }}
        with:
          result-encoding: string
          script: |
            const labels = [
              { key: 'created', value: process.env.TIMESTAMP },
              { key: 'authors', envKey: 'OCI_ANNOTATION_AUTHORS' },
              { key: 'url', envKey: 'OCI_ANNOTATION_URL' },
              { key: 'documentation', envKey: 'OCI_ANNOTATION_DOCUMENTATION' },
              { key: 'source', envKey: 'OCI_ANNOTATION_SOURCE' },
              { key: 'version', envKey: 'COMMIT_HASH' },
              { key: 'revision', envKey: 'COMMIT_HASH' },
              { key: 'vendor', envKey: 'OCI_ANNOTATION_VENDOR' },
              { key: 'licenses', envKey: 'OCI_ANNOTATION_LICENSES' },
              { key: 'ref.name', value: `${process.env.IMAGE}:${process.env.CLIENT_VERSION}-${process.env.COMMIT_HASH}` },
              { key: 'title', envKey: 'OCI_ANNOTATION_SERVER_TITLE' },
              { key: 'description', envKey: 'OCI_ANNOTATION_SERVER_DESCRIPTION' },
              { key: 'base.name', envKey: 'OCI_ANNOTATION_SERVER_BASE_NAME' },
            ].map(({ key, value, envKey }) => {
                const resolvedValue = value ?? process.env[envKey] ?? ''
                return `org.opencontainers.image.${key}=${resolvedValue}`
              })
              .join('\n')

            return labels

      - name: Build and push single-arch image
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: ${{ steps.platform.outputs.platform }}
          file: ./docker/server/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          provenance: false
          build-args: |
            VMANGOS_REVISION=${{ needs.setup.outputs.commit-hash }}
            VMANGOS_CLIENT_VERSION=${{ matrix.client-version }}
            VMANGOS_PATCHES_REPOSITORY_URL=${{ env.PATCHES_REPOSITORY_URL }}
          tags: ${{ steps.generate-tag.outputs.tag }}
          annotations: ${{ steps.generate-annotations.outputs.result }}
          labels: ${{ steps.generate-labels.outputs.result }}

  create-server-manifests:
    name: Create server multi-arch manifests
    needs: [setup, build-and-push-server-images]
    if: ${{ needs.setup.outputs.images-already-exist != 'true' && github.event_name != 'pull_request' }}
    runs-on: ubuntu-24.04
    strategy:
      fail-fast: true
      matrix:
        client-version: [5875, 5464, 5302, 5086, 4878, 4695, 4544]
    permissions:
      contents: read
      packages: write

    steps:
      - name: Log in to container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate timestamp
        id: generate-timestamp
        run: echo "timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      - name: Generate tags
        uses: actions/github-script@v8
        id: generate-tags
        env:
          COMMIT_HASH: ${{ needs.setup.outputs.commit-hash }}
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_SERVER }}
          CLIENT_VERSION: ${{ matrix.client-version }}
        with:
          result-encoding: string
          script: |
            const tags = []

            if (parseInt(process.env.CLIENT_VERSION) === 5875) {
              tags.push(`${process.env.IMAGE}:latest`)
            }

            tags.push(`${process.env.IMAGE}:${process.env.CLIENT_VERSION}`)
            tags.push(`${process.env.IMAGE}:${process.env.CLIENT_VERSION}-${process.env.COMMIT_HASH}`)

            return tags.join(' ')

      - name: Generate OCI annotations for index
        uses: actions/github-script@v8
        id: generate-annotations
        env:
          COMMIT_HASH: ${{ needs.setup.outputs.commit-hash }}
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_SERVER }}
          CLIENT_VERSION: ${{ matrix.client-version }}
          TIMESTAMP: ${{ steps.generate-timestamp.outputs.timestamp }}
        with:
          result-encoding: string
          script: |
            const annotations = [
              { key: 'created', value: process.env.TIMESTAMP },
              { key: 'authors', envKey: 'OCI_ANNOTATION_AUTHORS' },
              { key: 'url', envKey: 'OCI_ANNOTATION_URL' },
              { key: 'documentation', envKey: 'OCI_ANNOTATION_DOCUMENTATION' },
              { key: 'source', envKey: 'OCI_ANNOTATION_SOURCE' },
              { key: 'version', envKey: 'COMMIT_HASH' },
              { key: 'revision', envKey: 'COMMIT_HASH' },
              { key: 'vendor', envKey: 'OCI_ANNOTATION_VENDOR' },
              { key: 'licenses', envKey: 'OCI_ANNOTATION_LICENSES' },
              { key: 'ref.name', value: `${process.env.IMAGE}:${process.env.CLIENT_VERSION}-${process.env.COMMIT_HASH}` },
              { key: 'title', envKey: 'OCI_ANNOTATION_SERVER_TITLE' },
              { key: 'description', envKey: 'OCI_ANNOTATION_SERVER_DESCRIPTION' },
              { key: 'base.name', envKey: 'OCI_ANNOTATION_SERVER_BASE_NAME' },
            ].map(({ key, value, envKey }) => {
                const resolvedValue = value ?? process.env[envKey] ?? ''
                const escapedValue = resolvedValue.replace(/'/g, "'\\''")
                return `--annotation 'org.opencontainers.image.${key}=${escapedValue}'`
              })
              .join(' ')

            return annotations

      - name: Create and push multi-arch manifest
        run: |
          docker buildx imagetools create \
            ${{ steps.generate-annotations.outputs.result }} \
            -t ${{ steps.generate-tags.outputs.result }} \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_SERVER }}:${{ matrix.client-version }}-${{ needs.setup.outputs.commit-hash }}-amd64 \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_SERVER }}:${{ matrix.client-version }}-${{ needs.setup.outputs.commit-hash }}-arm64

  build-and-push-database-images:
    name: Build and push database images
    needs: [setup, create-server-manifests]
    if: ${{ needs.setup.outputs.images-already-exist != 'true' }}
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: true
      matrix:
        runner: [ubuntu-24.04, ubuntu-24.04-arm]
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine platform
        id: platform
        run: |
          if [ "${{ matrix.runner }}" == "ubuntu-24.04-arm" ]; then
            echo "platform=linux/arm64" >> $GITHUB_OUTPUT
            echo "arch=arm64" >> $GITHUB_OUTPUT
          else
            echo "platform=linux/amd64" >> $GITHUB_OUTPUT
            echo "arch=amd64" >> $GITHUB_OUTPUT
          fi

      - name: Generate timestamp
        id: generate-timestamp
        run: echo "timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      - name: Generate single-arch tag
        id: generate-tag
        run: |
          echo "tag=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DATABASE }}:${{ needs.setup.outputs.commit-hash }}-${{ steps.platform.outputs.arch }}" >> $GITHUB_OUTPUT

      - name: Generate OCI annotations
        uses: actions/github-script@v8
        id: generate-annotations
        env:
          COMMIT_HASH: ${{ needs.setup.outputs.commit-hash }}
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DATABASE }}
          TIMESTAMP: ${{ steps.generate-timestamp.outputs.timestamp }}
        with:
          result-encoding: string
          script: |
            const annotations = [
              { key: 'created', value: process.env.TIMESTAMP },
              { key: 'authors', envKey: 'OCI_ANNOTATION_AUTHORS' },
              { key: 'url', envKey: 'OCI_ANNOTATION_URL' },
              { key: 'documentation', envKey: 'OCI_ANNOTATION_DOCUMENTATION' },
              { key: 'source', envKey: 'OCI_ANNOTATION_SOURCE' },
              { key: 'version', envKey: 'COMMIT_HASH' },
              { key: 'revision', envKey: 'COMMIT_HASH' },
              { key: 'vendor', envKey: 'OCI_ANNOTATION_VENDOR' },
              { key: 'licenses', envKey: 'OCI_ANNOTATION_LICENSES' },
              { key: 'ref.name', value: `${process.env.IMAGE}:${process.env.COMMIT_HASH}` },
              { key: 'title', envKey: 'OCI_ANNOTATION_DATABASE_TITLE' },
              { key: 'description', envKey: 'OCI_ANNOTATION_DATABASE_DESCRIPTION' },
              { key: 'base.name', envKey: 'OCI_ANNOTATION_DATABASE_BASE_NAME' },
            ].map(({ key, value, envKey }) => {
                const resolvedValue = value ?? process.env[envKey] ?? ''
                const escapedValue = resolvedValue.replace(/'/g, "'\\''")
                return `--annotation 'org.opencontainers.image.${key}=${escapedValue}'`
              })
              .join(' ')

            return annotations

      - name: Generate OCI labels
        uses: actions/github-script@v8
        id: generate-labels
        env:
          COMMIT_HASH: ${{ needs.setup.outputs.commit-hash }}
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DATABASE }}
          TIMESTAMP: ${{ steps.generate-timestamp.outputs.timestamp }}
        with:
          result-encoding: string
          script: |
            const labels = [
              { key: 'created', value: process.env.TIMESTAMP },
              { key: 'authors', envKey: 'OCI_ANNOTATION_AUTHORS' },
              { key: 'url', envKey: 'OCI_ANNOTATION_URL' },
              { key: 'documentation', envKey: 'OCI_ANNOTATION_DOCUMENTATION' },
              { key: 'source', envKey: 'OCI_ANNOTATION_SOURCE' },
              { key: 'version', envKey: 'COMMIT_HASH' },
              { key: 'revision', envKey: 'COMMIT_HASH' },
              { key: 'vendor', envKey: 'OCI_ANNOTATION_VENDOR' },
              { key: 'licenses', envKey: 'OCI_ANNOTATION_LICENSES' },
              { key: 'ref.name', value: `${process.env.IMAGE}:${process.env.COMMIT_HASH}` },
              { key: 'title', envKey: 'OCI_ANNOTATION_DATABASE_TITLE' },
              { key: 'description', envKey: 'OCI_ANNOTATION_DATABASE_DESCRIPTION' },
              { key: 'base.name', envKey: 'OCI_ANNOTATION_DATABASE_BASE_NAME' },
            ].map(({ key, value, envKey }) => {
                const resolvedValue = value ?? process.env[envKey] ?? ''
                return `org.opencontainers.image.${key}=${resolvedValue}`
              })
              .join('\n')

            return labels

      - name: Build and push single-arch image
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: ${{ steps.platform.outputs.platform }}
          file: ./docker/database/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          provenance: false
          build-args: |
            VMANGOS_REVISION=${{ needs.setup.outputs.commit-hash }}
            VMANGOS_PATCHES_REPOSITORY_URL=${{ env.PATCHES_REPOSITORY_URL }}
          tags: ${{ steps.generate-tag.outputs.tag }}
          annotations: ${{ steps.generate-annotations.outputs.result }}
          labels: ${{ steps.generate-labels.outputs.result }}

  create-database-manifests:
    name: Create database multi-arch manifests
    needs: [setup, build-and-push-database-images]
    if: ${{ needs.setup.outputs.images-already-exist != 'true' && github.event_name != 'pull_request' }}
    runs-on: ubuntu-24.04
    permissions:
      contents: read
      packages: write

    steps:
      - name: Log in to container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate timestamp
        id: generate-timestamp
        run: echo "timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      - name: Generate tags
        uses: actions/github-script@v8
        id: generate-tags
        env:
          COMMIT_HASH: ${{ needs.setup.outputs.commit-hash }}
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DATABASE }}
        with:
          result-encoding: string
          script: |
            const tags = []

            tags.push(`${process.env.IMAGE}:latest`)
            tags.push(`${process.env.IMAGE}:${process.env.COMMIT_HASH}`)

            return tags.join(' ')

      - name: Generate OCI annotations for index
        uses: actions/github-script@v8
        id: generate-annotations
        env:
          COMMIT_HASH: ${{ needs.setup.outputs.commit-hash }}
          IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DATABASE }}
          TIMESTAMP: ${{ steps.generate-timestamp.outputs.timestamp }}
        with:
          result-encoding: string
          script: |
            const annotations = [
              { key: 'created', value: process.env.TIMESTAMP },
              { key: 'authors', envKey: 'OCI_ANNOTATION_AUTHORS' },
              { key: 'url', envKey: 'OCI_ANNOTATION_URL' },
              { key: 'documentation', envKey: 'OCI_ANNOTATION_DOCUMENTATION' },
              { key: 'source', envKey: 'OCI_ANNOTATION_SOURCE' },
              { key: 'version', envKey: 'COMMIT_HASH' },
              { key: 'revision', envKey: 'COMMIT_HASH' },
              { key: 'vendor', envKey: 'OCI_ANNOTATION_VENDOR' },
              { key: 'licenses', envKey: 'OCI_ANNOTATION_LICENSES' },
              { key: 'ref.name', value: `${process.env.IMAGE}:${process.env.COMMIT_HASH}` },
              { key: 'title', envKey: 'OCI_ANNOTATION_DATABASE_TITLE' },
              { key: 'description', envKey: 'OCI_ANNOTATION_DATABASE_DESCRIPTION' },
              { key: 'base.name', envKey: 'OCI_ANNOTATION_DATABASE_BASE_NAME' },
            ].map(({ key, value, envKey }) => {
                const resolvedValue = value ?? process.env[envKey] ?? ''
                const escapedValue = resolvedValue.replace(/'/g, "'\\''")
                return `--annotation 'org.opencontainers.image.${key}=${escapedValue}'`
              })
              .join(' ')

            return annotations

      - name: Create and push multi-arch manifest
        run: |
          docker buildx imagetools create \
            ${{ steps.generate-annotations.outputs.result }} \
            -t ${{ steps.generate-tags.outputs.result }} \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_DATABASE }}:${{ needs.setup.outputs.commit_h
